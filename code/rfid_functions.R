######## Functions to read, clean, and manipulate data ########

# Function to perform sliding window analysis to remove transitions into current zone

identify_duplicate_records <- function(records){
  records$duplicate <- rep(0, length(records$subzone))
  records <- records[order(records$accessdate),]
  
  for(i in 3:length(records$subzone)){

    primary <- records[i-2,]
    secondary <- records[i-1,]
    tertiary <- records[i,]
    #print(primary)

    #print(paste(primary$subzone," : ",secondary$subzone))
  
  
    #check if primary zone is same as secondary zone
    if(length(unique(c(primary$subzone,secondary$subzone,tertiary$subzone)))!=3){
      if(primary$subzone != secondary$subzone){
        records[[i-2,"duplicate"]] <- 1
      } else if(secondary$subzone != tertiary$subzone){
        records[[i-1,"duplicate"]] <- 1
      }
    }

  }
  return(records)
}

# Function to select Tsibble between timepoints given (used to get contiguous time series of records)

sliceTsibble <- function(data, start, stop){
  
  previous_state <- tail(data[data$datetime <= ymd_hms(start),],n=1)
  greater_than_start <- data[data$datetime >= ymd_hms(start),]
  less_than_end <- greater_than_start[greater_than_start$datetime <= ymd_hms(stop),]
  final_state <- head(greater_than_start[greater_than_start$datetime >= ymd_hms(stop),],n=1)


  if(nrow(less_than_end) == 0){
    less_than_end <- NA
    return(less_than_end)
  }

  previous_state$datetime <- ymd_hms(start)
  final_state$datetime <- ymd_hms(stop)
  less_than_end <- bind_rows(less_than_end, previous_state)
  less_than_end <- bind_rows(less_than_end, final_state)
  return(less_than_end)
  
}

# Function to round the start so that records start nicely

nice_start <- function(dataframe, units, interval_min){
  requireNamespace("lubridate")
  dataframe[1,1]$datetime <- round_date(ymd_hms(dataframe[1,1]$datetime), unit=units)
  
  # remove duplicate entries 
  #dataframe <- dataframe[!duplicates(dataframe)]
  dataframe <- dataframe |> 
    distinct(datetime, .keep_all=TRUE)
  dataframe <- tsibble(dataframe,index= datetime)

  attr(dataframe, 'interval') <- new_interval(min=interval_min)
  return(dataframe)
}

# from Analyis.R generated by Keni
# calculates the proportion of time spent in each zone based on the whole time series passed in
# TODO remove the TBStag$t <- 1 stuff possibly
getTimeBudgetProp <- function(data) {
  columns = c("interval","Bottom","Middle","Top") 
  TBS = data.frame(matrix(nrow = 0, ncol = length(columns))) 
  colnames(TBS) = columns

  if(all.equal(colnames(data),c("t1","t2","from_zone","to_zone"))){
    # store inteval as minutes
    TBStag<- data.frame(t = (as.numeric(data$t2) - as.numeric(data$t1)) / 60, to_zone=data$to_zone)
    Interval <- c(ymd_hms(as.POSIXct.numeric(as.numeric(head(data,n=1)$t1),origin=origin)),ymd_hms(as.POSIXct.numeric(as.numeric(tail(data,n=1)$t2),origin=origin)))

    TBbot<-sum(TBStag[which(TBStag$to_zone == "bottom"),]$t)/sum(TBStag$t)
        
    TBmid<-sum(TBStag[which(TBStag$to_zone == "middle"),]$t)/sum(TBStag$t)
        
    TBtop<-sum(TBStag[which(TBStag$to_zone == "top"),]$t)/sum(TBStag$t)
      
    TBS<-matrix(c(TBbot,TBmid,TBtop),ncol=3)

    return(data.frame(Interval[1],Interval[2],TBS))

  } else if(all.equal(colnames(data),c("t1","t2","zone"))){
      # store inteval as minutes
    TBStag<- data.frame(t = (as.numeric(data$t2) - as.numeric(data$t1)) / 60, zone=data$zone)

    Interval <- c(ymd_hms(as.POSIXct.numeric(as.numeric(head(data,n=1)$t1),origin=origin)),ymd_hms(as.POSIXct.numeric(as.numeric(tail(data,n=1)$t2),origin=origin)))

    TBbot<-sum(TBStag[which(TBStag$zone == "bottom"),]$t)/sum(TBStag$t)
        
    TBmid<-sum(TBStag[which(TBStag$zone == "middle"),]$t)/sum(TBStag$t)
        
    TBtop<-sum(TBStag[which(TBStag$zone == "top"),]$t)/sum(TBStag$t)
      
    TBS<-matrix(c(TBbot,TBmid,TBtop),ncol=3)

    return(data.frame(Interval[1],Interval[2],TBS))
  } else {
    print("this should not happen")
    exit(0)
  }
  
}

# Function to calculate absolute time spent in each zone

getTimeBudgetAbs <- function(data) {
  columns = c("Bottom","Middle","Top") 
  TBS = data.frame(matrix(nrow = 0, ncol = length(columns))) 
  colnames(TBS) = columns

  # store inteval as minutes
  TBStag<- data.frame(t = (as.numeric(data$t2) - as.numeric(data$t1)) / 60, zone=data$zone)

  TBbot<-sum(TBStag[which(TBStag$to_zone == "bottom"),]$t)
    
  TBmid<-sum(TBStag[which(TBStag$to_zone == "middle"),]$t)
     
  TBtop<-sum(TBStag[which(TBStag$to_zone == "top"),]$t)

  TBS<-matrix(c(TBbot,TBmid,TBtop),ncol=3)
     
  return(TBS)
  
}

# # Calculate the Proportional Time budget based on the day and night tables (zone is changed)

# getTimeBudgetPropDayNight <- function(data) {
#   columns = c("interval","Bottom","Middle","Top") 
#   TBS = data.frame(matrix(nrow = 0, ncol = length(columns))) 
#   colnames(TBS) = columns

#   # store inteval as minutes
#   TBStag<- data.frame(t = (as.numeric(data$t2) - as.numeric(data$t1)) / 60, zone=data$to_zone)

#   Interval <- c(ymd_hms(as.POSIXct.numeric(as.numeric(head(data,n=1)$t1),origin=origin)),ymd_hms(as.POSIXct.numeric(as.numeric(tail(data,n=1)$t2),origin=origin)))

#   TBbot<-sum(TBStag[which(TBStag$zone == "bottom"),]$t)/sum(TBStag$t)
    
#   TBmid<-sum(TBStag[which(TBStag$zone == "middle"),]$t)/sum(TBStag$t)
     
#   TBtop<-sum(TBStag[which(TBStag$zone == "top"),]$t)/sum(TBStag$t)
     
#   TBS<-matrix(c(TBbot,TBmid,TBtop),ncol=3)
     
#   return(data.frame(Interval[1],Interval[2],TBS))
  
# }

# Splits out day records based on day timepoints given returns datafram with day and week of study embedded

getDayRecords <- function(data, start, end){
  data$day <- (format(data$datetime, "%H:%M") >= start & format(data$datetime, "%H:%M") < end)

  day <- data[data$day == TRUE,]

  day$date <- format(day$datetime, "%Y/%m/%d")

  date_to_day <- data.frame(cbind(unique(day$date),1:length(unique(day$date))))

  colnames(date_to_day) <- c('datetime','dos')

  day$dos <- as.numeric(date_to_day[match(format(day$datetime, "%Y/%m/%d"), date_to_day$datetime),2])

  week_offset <- as.numeric(format(day$datetime, "%-V")[1])

  day$wos <- (as.numeric(format(day$datetime, "%-V"))-week_offset)+1

  return(day)
}

# Splits out night records based on day timepoints given returns datafram with day and week of study embedded

getNightRecords <- function(data, start, end){

  first_day_of_study <- format(data[1]$datetime,"%Y/%m/%d")

  data$day <- (format(data$datetime, "%H:%M") >= start & format(data$datetime, "%H:%M") < end)

  night <- data[data$day != TRUE,]

  night$date <- format(night$datetime, "%Y/%m/%d")

  night_dates <- c(first_day_of_study, night$date)

  date_to_day <- data.frame(cbind(unique(night_dates),1:length(unique(night_dates))))

  colnames(date_to_day) <- c('datetime','dos')

  #night$dos <- as.numeric(date_to_day[match(format(night$datetime, "%Y/%m/%d"), date_to_day$datetime),2])

  # TODD if you change hour cutoffs need to change range here
  night$dos <- ifelse(hour(night$datetime) %in% c(0,1,2,3),as.numeric(date_to_day[match(format(night$datetime, "%Y/%m/%d"), date_to_day$datetime),2])-1, as.numeric(date_to_day[match(format(night$datetime, "%Y/%m/%d"), date_to_day$datetime),2]))


  #night$dos <- as.numeric(date_to_day[match(format(night$datetime, "%Y/%m/%d"), date_to_day$datetime),2])

  # Possibly fix this item
  week_offset <- as.numeric(format(night$datetime, "%-V")[1])

  night$wos <- (as.numeric(format(night$datetime, "%-V"))-week_offset)+1

  return(night)
}

# Function to turn nested day tables into interval tables

nestedTimeToIntervals <- function(data){
  #TODO decide how to return this and/or make a special time budget function that nests the data before it calculates the budget.
  # I'm going to remove date as the nesting function
  tmp <- data |> 
  nest(by_day = -c(dos)) |>
  mutate(daily_int = map(by_day, ~timeToIntervals(.x))) #|>
  #unnest(daily_int)

  return(tmp)
}

# Function to turn time table into interval table, handles case of 0,1,2,...n transtitions
# TODO remove cases we dont need
timeToIntervals <- function(data){
  requireNamespace("dplyr")

  interval_table <- data.frame()

  first_entry <- head(data,n=1)
  transition_into <- data[which(data$value != dplyr::lag(data$value)),]
  transition_from <- data[which(data$value != dplyr::lag(data$value))-1,]
  last_entry <- tail(data,n=1)

  if(length(transition_into$datetime) == 0){

    new_row <- cbind(ymd_hms(first_entry$datetime),ymd_hms(last_entry$datetime),NA, as.character(first_entry$value))
    interval_table <- rbind(interval_table, new_row)
    colnames(interval_table) <- c("t1","t2","from_zone","to_zone")

  } else if( length(transition_into$value) == 1){

    new_row <- cbind(ymd_hms(first_entry$datetime),ymd_hms(transition_into[1,]$datetime),NA, as.character(first_entry$value))
    interval_table <- rbind(interval_table, new_row)
    
    new_row <- cbind(ymd_hms(transition_into[1,]$datetime), ymd_hms(last_entry[1,]$datetime),as.character(transition_from[1,2]),as.character(transition_into[1,2]))
    interval_table <- rbind(interval_table, new_row)
    colnames(interval_table) <- c("t1","t2","from_zone","to_zone")

  } else if(length(transition_into$value) == 2){

    new_row <- cbind(ymd_hms(first_entry$datetime),ymd_hms(transition_into[1,]$datetime),NA, as.character(first_entry$value))
    interval_table <- rbind(interval_table, new_row)
    
    new_row <- cbind(ymd_hms(transition_into[1,]$datetime), ymd_hms(transition_into[2,]$datetime),as.character(transition_from[1,2]),as.character(transition_into[1,2]))
    interval_table <- rbind(interval_table, new_row)
    new_row <- cbind(ymd_hms(transition_into[2,]$datetime), ymd_hms(last_entry$datetime),as.character(transition_from[2,2]),as.character(last_entry[,2]))
    interval_table <- rbind(interval_table, new_row)
    colnames(interval_table) <- c("t1","t2","from_zone","to_zone")

  } else if(length(transition_into$value) > 2) {

    new_row <- cbind(ymd_hms(first_entry$datetime),ymd_hms(transition_into[1,]$datetime),NA, as.character(first_entry$value))
    interval_table <- rbind(interval_table, new_row)

    for(i in 1:length(transition_into$value)){
      new_row <- cbind(ymd_hms(transition_into[i,]$datetime), ymd_hms(transition_into[i+1,]$datetime),as.character(transition_from[i,2]),as.character(transition_into[i,2]))
      interval_table <- rbind(interval_table, new_row)
    }

    colnames(interval_table) <- c("t1","t2","from_zone","to_zone")
    interval_table[length(interval_table$t2),]$t2 <- last_entry$datetime

  } else {

    print("this shouldn't happen")
    exit(0)

  }

  return(interval_table)

}

nightZoneFromTB <- function(data){
  
}

