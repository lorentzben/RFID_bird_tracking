---
title: "RFID Room 2"
output:
  pdf_document: default
  html_notebook: default
  html_document:
    df_print: paged
---


# Data Preprocessing

```{r function to clean data from duplicate reads}
identify_duplicate_records <- function(records){
  records$duplicate <- rep(0, length(records$subzone))
  records <- records[order(records$accessdate),]
  
  for(i in 3:length(records$subzone)){

    primary <- records[i-2,]
    secondary <- records[i-1,]
    tertiary <- records[i,]
    #print(primary)

    #print(paste(primary$subzone," : ",secondary$subzone))
  
  
    #check if primary zone is same as secondary zone
    if(length(unique(c(primary$subzone,secondary$subzone,tertiary$subzone)))!=3){
      if(primary$subzone != secondary$subzone){
        records[[i-2,"duplicate"]] <- 1
      } else if(secondary$subzone != tertiary$subzone){
        records[[i-1,"duplicate"]] <- 1
      }
    }

  }
  return(records)
}

```

```{r from Keni's data}
# from Analyis.R generated by Keni
# calculates the proportion of time spent in each zone based on the whole time series passed in
 getTimeBudget <- function(data) {
  columns = c("Bottom","Middle","Top") 
  TBS = data.frame(matrix(nrow = 0, ncol = length(columns))) 
  colnames(TBS) = columns

  # store inteval as minutes
  TBStag<- data.frame(t = (as.numeric(data$t2) - as.numeric(data$t1)) / 60, zone=data$zone)

  TBbot<-sum(TBStag[which(TBStag$zone == "bottom"),]$t)/sum(TBStag$t)
    
  TBmid<-sum(TBStag[which(TBStag$zone == "middle"),]$t)/sum(TBStag$t)
     
  TBtop<-sum(TBStag[which(TBStag$zone == "top"),]$t)/sum(TBStag$t)
     
  TBS<-matrix(c(TBbot,TBmid,TBtop),ncol=3)
     
  return(TBS)
  
}

timeToIntervals <- function(data){
  requireNamespace("dplyr")

  interval_table <- data.frame()

  first_entry <- head(data,n=1)
  transition_into <- data[which(data$value != dplyr::lag(data$value)),]
  last_entry <- tail(data,n=1)


  new_row <- cbind(ymd_hms(first_entry$datetime),ymd_hms(transition_into[1,]$datetime),as.character(first_entry$value))
  interval_table <- rbind(interval_table, new_row)

  for(i in 2:length(transition_into$value)-1){
    new_row <- cbind(ymd_hms(transition_into[i,]$datetime), ymd_hms(transition_into[i+1,]$datetime),as.character(transition_into[i,2]))
    interval_table <- rbind(interval_table, new_row)
  }
  colnames(interval_table) <- c("t1","t2","zone")
  interval_table[length(interval_table$t2),]$t2 <- last_entry$datetime

  return(interval_table)

}
```

```{r nice start function}

nice_start <- function(dataframe, units, interval_min){
  requireNamespace("lubridate")
  dataframe[1,1]$datetime <- round_date(ymd_hms(dataframe[1,1]$datetime), unit=units)
  attr(dataframe, 'interval') <- new_interval(min=interval_min)
  # remove duplicate entries 
  #dataframe <- dataframe[!duplicates(dataframe)]

  return(dataframe)
}

```

## Import Room 2

```{r generate transition tables for room 2}

library(xts)
library(lubridate)
library(tidyverse)
library(tidyr)
library(dplyr)
library(tsibble)


room_2 <- read.csv("../data/DK20-03-RFID-R2-febmay-080423.csv")

bird_ids_room_2 <- unique(room_2$tagname)
bird_ids_room_2 <- na.trim(sort(bird_ids_room_2))

room_2["DateTime"] <- as.POSIXct(room_2$access, origin="1970-01-01", tz="GMT")

print("what makes up subzone col")
unique(room_2$subzone)

room_2$subzone[room_2$subzone == "Bottom"] <- "bottom"
room_2$subzone[room_2$subzone == "Middle"] <- "middle"
room_2$subzone[room_2$subzone == "Top"] <- "top"


print("what makes up subzone col")
unique(room_2$subzone)

print("how many NAs in DateTime and Subzone")
sum(is.na(room_2$DateTime))
sum(is.na(room_2$subzone))

room_2$accessdate <- dmy_hms(room_2$accessdate)

# find the five number summary to determine the median interval in seconds of each reading to determine the proper sampling interval
# mean of the median times for room 2 is 9 minutes so move up to 10 minutes
# mean of the mean times for room 2 is 38 minutes so move down to every 30 minutes
room_2_summary <- room_2 |> nest(data = - tagname) |> 
 na.exclude() |>
 mutate(id_dupes = map(data ,~identify_duplicate_records(.x))) |>
 mutate(cleaned = map(id_dupes, ~.x[! .x$duplicate == 1,])) |>
 mutate(tsibble = map(cleaned, ~tsibble(datetime = ymd_hms(.x$accessdate), value = .x$subzone, index = datetime) )) |>
 mutate(intervals_s = map(tsibble, ~ as.numeric(difftime(.x$datetime[1:(length(.x$datetime)-1)], .x$datetime[2:length(.x$datetime)],units='secs') ))) |>
 mutate(summary = map(intervals_s, ~summary(.x))) |>
 mutate(minimum = map(summary, ~abs(.x[6]))) |>
 mutate(median = map(summary, ~.x[3])) |>
 mutate(mean = map(summary, ~.x[4])) |>
 unnest(c(minimum, median,mean))

# Time in minutes and min in sec of average duration between transitions
(mean(room_2_summary$median)/60)
(mean(room_2_summary$mean)/60)
(min(room_2_summary$minimum))

# when is a nice time to start the study?

# No Room 3 2021-02-18 T23:30:00/2021-05-06 T23:00:00
# All Rooms 2021-03-09 T20:00:00/2021-05-06 T23:00:00

# 
room_2_struct <- room_2 |> nest(data = - tagname) |> 
 na.exclude() |>
 mutate(id_dupes = map(data ,~identify_duplicate_records(.x))) |>
 mutate(cleaned = map(id_dupes, ~.x[! .x$duplicate == 1,])) |>
 mutate(tsibble = map(cleaned, ~tsibble(datetime = ymd_hms(.x$accessdate), value = .x$subzone, index = datetime) ))

# round the first entry to the nearest 10 minute interval to provide a nice sampling interval, then interpolate the rest of the intervals
room_2_regular <- room_2_struct |>
 select(c(tagname,tsibble)) |> 
 mutate(near_5 = map(tsibble, ~ nice_start(.x, "5 seconds",5/60))) |>
 mutate(perSec = map(near_5, ~ fill_gaps(.x)))|>
 mutate(sampled = map(perSec, ~ na.locf(.x))) 

room_2_dupes <- room_2_regular |>
  select(tagname, sampled) |> 
  mutate(duplicates = map(sampled, ~duplicates(.x)))

room_2_interval <- room_2_regular |>
  mutate(interval = map(sampled, ~timeToIntervals(.x)))

# TODO need to set start and end timepoints for this dataset.
room_2_time_budget <- room_2_interval |>
  mutate(tb = map(interval, ~ getTimeBudget(.x))) |>
  unnest(tb)
```

## Import Room 3

```{r import room 3}
library(xts)
library(lubridate)
library(tidyverse)
library(tidyr)
library(dplyr)
library(tsibble)

room_3 <- read.csv("../data/DK20-03-RFID-R3-febmay-080423.csv") %>% na.exclude()

bird_ids_room_3 <- unique(room_3$tagname)
bird_ids_room_3 <- na.trim(sort(bird_ids_room_3))

room_3["DateTime"] <- as.POSIXct(room_3$access, origin="1970-01-01", tz="GMT")

print("what makes up subzone col")
unique(room_3$subzone)

room_3$subzone[room_3$subzone == "Bottom"] <- "bottom"
room_3$subzone[room_3$subzone == "Middle"] <- "middle"
room_3$subzone[room_3$subzone == "Top"] <- "top"


print("what makes up subzone col")
unique(room_3$subzone)

print("how many NA's are in Datetime and Subzone")
sum(is.na(room_3$DateTime))
sum(is.na(room_3$subzone))

room_3 <- room_3[!is.na(room_3$DateTime),]

print("how many NA's are in Datetime and Subzone")
sum(is.na(room_3$DateTime))
sum(is.na(room_3$subzone))

room_3$accessdate <- dmy_hms(room_3$accessdate)

room_3_summary <- room_3 |> nest(data = - tagname) |> 
 na.exclude() |>
 mutate(id_dupes = map(data ,~identify_duplicate_records(.x))) |>
 mutate(cleaned = map(id_dupes, ~.x[! .x$duplicate == 1,])) |>
 mutate(tsibble = map(cleaned, ~tsibble(datetime = ymd_hms(.x$accessdate), value = .x$subzone, index = datetime) )) |>
 mutate(intervals_s = map(tsibble, ~ as.numeric(difftime(.x$datetime[1:(length(.x$datetime)-1)], .x$datetime[2:length(.x$datetime)],units='secs') ))) |>
 mutate(summary = map(intervals_s, ~summary(.x))) |>
 mutate(minimum = map(summary, ~abs(.x[6]))) |>
 mutate(median = map(summary, ~.x[3])) |>
 mutate(mean = map(summary, ~.x[4])) |>
 unnest(c(minimum, median,mean))

# Time in minutes and min in sec of average duration between transitions
(mean(room_3_summary$median)/60)
(mean(room_3_summary$mean)/60)
(min(room_3_summary$minimum))

room_3_struct <- room_3 |> nest(data = - tagname) |> 
 na.exclude() |>
 mutate(id_dupes = map(data ,~identify_duplicate_records(.x))) |>
 mutate(cleaned = map(id_dupes, ~.x[! .x$duplicate == 1,])) |>
 mutate(tsibble = map(cleaned, ~tsibble(datetime = ymd_hms(.x$accessdate), value = .x$subzone, index = datetime) ))
 

# round the first entry to the nearest 10 minute interval to provide a nice sampling interval, then interpolate the rest of the intervals
room_3_regular <- room_3_struct |>
 mutate(near_5 = map(tsibble, ~ nice_start(.x, "5 seconds",5/60))) |>
 mutate(perSec = map(near_5, ~ fill_gaps(.x))) |>
 mutate(sampled = map(perSec, ~ na.locf(.x))) 

room_3_dupes <- room_3_regular |>
  select(tagname, sampled) |> 
  mutate(duplicates = map(sampled, ~duplicates(.x)))
```

## Import Room 8

```{r import Room 8}
library(xts)
library(lubridate)
library(tidyverse)
library(tidyr)
library(dplyr)
library(tsibble)

room_8 <- read.csv("../data/DK20-03-RFID-r8-febmay-080423.csv") %>% na.exclude()

bird_ids_room_8 <- na.trim(unique(room_8$tagname))
bird_ids_room_8 <- sort(bird_ids_room_8)

room_8["DateTime"] <- as.POSIXct(room_8$access, origin="1970-01-01", tz="GMT")

print("what makes up subzone col")
unique(room_8$subzone)

room_8$subzone[room_8$subzone == "Bottom"] <- "bottom"
room_8$subzone[room_8$subzone == "middle"] <- "middle"
room_8$subzone[room_8$subzone == "Top"] <- "top"
room_8 <-subset(room_8, subzone!="test")

print("what makes up subzone col")
unique(room_8$subzone)

print("how many NA's in Datetime and Subzone")
sum(is.na(room_8$DateTime))
sum(is.na(room_8$subzone))

room_8 <- room_8[!is.na(room_8$DateTime),]

room_8$accessdate <- dmy_hms(room_8$accessdate)



room_8_summary <- room_8 |> nest(data = - tagname) |> 
 na.exclude() |>
 mutate(id_dupes = map(data ,~identify_duplicate_records(.x))) |>
 mutate(cleaned = map(id_dupes, ~.x[! .x$duplicate == 1,])) |>
 mutate(tsibble = map(cleaned, ~tsibble(datetime = ymd_hms(.x$accessdate), value = .x$subzone, index = datetime) )) |>
 mutate(intervals_s = map(tsibble, ~ as.numeric(difftime(.x$datetime[1:(length(.x$datetime)-1)], .x$datetime[2:length(.x$datetime)],units='secs') ))) |>
 mutate(summary = map(intervals_s, ~summary(.x))) |>
 mutate(minimum = map(summary, ~abs(.x[6]))) |>
 mutate(median = map(summary, ~.x[3])) |>
 mutate(mean = map(summary, ~.x[4])) |>
 unnest(c(minimum, median,mean))

# Time in minutes and min in sec of average duration between transitions
(mean(room_8_summary$median)/60)
(mean(room_8_summary$mean)/60)
(min(room_8_summary$minimum))

room_8_struct <- room_8 |> nest(data = - tagname) |> 
 na.exclude() |>
 mutate(id_dupes = map(data ,~identify_duplicate_records(.x))) |>
 mutate(cleaned = map(id_dupes, ~.x[! .x$duplicate == 1,])) |>
 mutate(tsibble = map(cleaned, ~tsibble(datetime = ymd_hms(.x$accessdate), value = .x$subzone, index = datetime) ))
 

# round the first entry to the nearest 10 minute interval to provide a nice sampling interval, then interpolate the rest of the intervals
room_8_regular <- room_8_struct |>
 mutate(near_5 = map(tsibble, ~ nice_start(.x, "5 seconds",5/60))) |>
 mutate(perSec = map(near_5, ~ fill_gaps(.x))) |>
 mutate(sampled = map(perSec, ~ na.locf(.x))) 

room_8_dupes <- room_8_regular |>
  select(tagname, sampled) |> 
  mutate(duplicates = map(sampled, ~duplicates(.x)))
```

## Import Room 11

```{r import Room 11}
library(xts)
library(lubridate)
library(tidyverse)
library(tidyr)
library(dplyr)
library(tsibble)

room_11 <- read.csv("../data/DK20-03-RFID-R11-febmay-080423.csv") %>% na.exclude()

bird_ids_room_11 <- na.trim(unique(room_11$tagname))
bird_ids_room_11 <- sort(bird_ids_room_11)

room_11 <- room_11[order(room_11$accessdate),] 

room_11["DateTime"] <- as.POSIXct(room_11$access, origin="1970-01-01", tz="GMT")

print("what composes the subzone column")
unique(room_11$subzone)

room_11$subzone[room_11$subzone == "M"] <- "middle"
room_11$subzone[room_11$subzone == "B"] <- "bottom"
room_11$subzone[room_11$subzone == "T"] <- "top"

print("what composes the subzone column")
unique(room_11$subzone)

print("how many NA's in the DateTime col")
sum(is.na(room_11$DateTime))

room_11 <- room_11[!is.na(room_11$DateTime),]

print("how many NA's in the Datetime col")
sum(is.na(room_11$DateTime))

room_11$accessdate <- dmy_hms(room_11$accessdate)

room_11_summary <- room_11 |> nest(data = - tagname) |> 
 na.exclude() |>
 mutate(id_dupes = map(data ,~identify_duplicate_records(.x))) |>
 mutate(cleaned = map(id_dupes, ~.x[! .x$duplicate == 1,])) |>
 mutate(tsibble = map(cleaned, ~tsibble(datetime = ymd_hms(.x$accessdate), value = .x$subzone, index = datetime) )) |>
 mutate(intervals_s = map(tsibble, ~ as.numeric(difftime(.x$datetime[1:(length(.x$datetime)-1)], .x$datetime[2:length(.x$datetime)],units='secs') ))) |>
 mutate(summary = map(intervals_s, ~summary(.x))) |>
 mutate(minimum = map(summary, ~abs(.x[6]))) |>
 mutate(median = map(summary, ~.x[3])) |>
 mutate(mean = map(summary, ~.x[4])) |>
 unnest(c(minimum, median,mean))

# Time in minutes and min in sec of average duration between transitions
(mean(room_11_summary$median)/60)
(mean(room_11_summary$mean)/60)
(min(room_11_summary$minimum))

room_11_struct <- room_11 |> nest(data = - tagname) |> 
 na.exclude() |>
 mutate(id_dupes = map(data ,~identify_duplicate_records(.x))) |>
 mutate(cleaned = map(id_dupes, ~.x[! .x$duplicate == 1,])) |>
 mutate(tsibble = map(cleaned, ~tsibble(datetime = ymd_hms(.x$accessdate), value = .x$subzone, index = datetime) ))
 

# round the first entry to the nearest 10 minute interval to provide a nice sampling interval, then interpolate the rest of the intervals
room_11_regular <- room_11_struct |>
 mutate(near_5 = map(tsibble, ~ nice_start(.x, "5 seconds",5/60))) |>
 mutate(perSec = map(near_5, ~ fill_gaps(.x))) |>
 mutate(sampled = map(perSec, ~ na.locf(.x))) 

#check duplicates

room_11_dupes <- room_11_regular |>
  select(tagname, sampled) |> 
  mutate(duplicates = map(sampled, ~duplicates(.x))) 

# all good
```
# Time Budget Analysis